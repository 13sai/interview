参考：[goroutine调度详解，以及进程、线程、协程区别](https://blog.csdn.net/Arlingtonroad/article/details/106952053)

## 进程

通俗点讲，程序（比如你写的爬虫程序，http服务器等）运行起来就是进程。

每个进程都有自己的独立内存空间，拥有自己独立的地址空间、独立的堆和栈，既不共享堆，亦不共享栈。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

**操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位**。

### 进程间的通信方式

- 管道(Pipe)
- 命名管道(FIFO)
- 消息队列(Message Queue)
- 信号量(Semaphore)
- 共享内存（Shared Memory）
- 套接字（Socket）

## 线程

**有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位**。（注意进程是操作系统分配资源的最小单位）。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。总的来说，进程和线程的区别如下：

- **线程是调度执行的基本单位，进程作为拥有资源的基本单位**；
- 进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。进程所维护的是程序所包含的资源（静态资源）， 如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler等；线程所维护的运行相关的资源（动态资源），如：运行栈，调度相关的控制信息，待处理的信号集等；
- 在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。

## 协程

协程是一种用户态的轻量级线程，协程的调度完全由用户控制（即协程相对于操作系统来说是透明的，操作系统根本不知道协程的存在）。协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

## goroutine

go语言中并发指的是让某个函数独立于其他函数运行的能力，一个goroutine就是一个独立的工作单元，Go的runtime（运行时）会在**逻辑处理器**上调度这些goroutine来运行，一个**逻辑处理器**绑定一个操作系统线程，所以说goroutine不是线程，它是一个协程，也是这个原因，它是由Go语言运行时本身的算法实现的。

这里我们总结下几个概念：

| 概念         | 说明                                                         |
| :----------- | :----------------------------------------------------------- |
| 进程         | 一个程序对应一个独立程序空间                                 |
| 线程         | 一个执行空间，一个进程可以有多个线程                         |
| 逻辑处理器   | 执行创建的goroutine，绑定一个线程（指的是操作系统线程，即内核线程） |
| 调度器       | Go运行时中的，分配goroutine给不同的逻辑处理器                |
| 全局运行队列 | 所有刚创建的goroutine都会放到这里                            |
| 本地运行队列 | 逻辑处理器的goroutine队列                                    |

当我们创建一个goroutine的后，会先存放在`全局运行队列`中，等待Go运行时的`调度器`进行调度，把他们分配给其中的一个`逻辑处理器`，并放到这个逻辑处理器对应的`本地运行队列`中，最终等着被`逻辑处理器`执行即可。



附：

> 寄存器是CPU内部的存储单元，用于存放从内存读取而来的数据（包括指令）和CPU运算的中间结果，之所以要使用寄存器来临时存放数据而不是直接操作内存，一是因为CPU的工作原理决定了有些操作运算只能在CPU内部进行，二是因为CPU读写寄存器的速度比读写内存的速度快得多。

