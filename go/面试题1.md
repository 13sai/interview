### 通道特性
- 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的（并发安全）
- 发送操作和接收操作中对元素值的处理都是不可分割的。
- 发送操作在完全完成之前会被阻塞，接收操作也是一样。
- 对于缓冲通道：如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走；如果通道已空，那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。
- 对于非缓冲通道：无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。


注意点：

关闭通道要在发送方关闭，关闭后如果channel内还有元素，并不会对接下来的接收产生影响
单向通道最主要的用途就是约束其他代码的行为
通过函数的参数类型或者返回值类型来限制（Go的语法糖）。

### 说说go语言中，数组与切片的区别？

#### 数组 
数组是具有固定长度且拥有零个或者多个相同数据类型元素的序列。 数组的长度是数组类型的一部分，所以[3]int 和 [4]int 是两种不同的数组类型。

数组需要指定大小，不指定也会根据初始化的自动推算出大小，不可改变 ;

数组是值传递;

数组是内置(build-in)类型,是一组同类型数据的集合，它是值类型，通过从0开始的下标索引访问元素值。在初始化后长度是固定的，无法修改其长度。当作为方法的参数传入时将复制一份数组而不是引用同一指针。数组的长度也是其类型的一部分，通过内置函数len(array)获取其长度。

数组定义：

```
var array [10]int
var array = [5]int{1,2,3,4,5}
```

#### 切片 
切片表示一个拥有相同类型元素的可变长度的序列。 切片是一种轻量级的数据结构，它有三个属性：指针、长度和容量。

切片不需要指定大小;切片是地址传递;切片可以通过数组来初始化，也可以通过内置函数make()初始化 .初始化时len=cap,在追加元素时如果容量cap不足时将按len的2倍扩容；

切片定义：

```
var slice []type = make([]type, len)
```

### 解释以下命令的作用？
```
go env: #用于查看go的环境变量
go run: #用于编译并运行go源码文件
go build: #用于编译源码文件、代码包、依赖包
go get: #用于动态获取远程代码包
go install: #用于编译go文件，并将编译结构安装到bin、pkg目录
go clean: #用于清理工作目录，删除编译和安装遗留的目标文件
go version: #用于查看go的版本信息
```

### 说说go语言中的协程？

协程和线程都可以实现程序的并发执行；

通过channel来进行协程间的通信；

只需要在函数调用前添加go关键字即可实现go的协程，创建并发任务；

关键字go并非执行并发任务，而是创建一个并发任务单元；

### 说说go语言中的for循环？

for循环支持continue和break来控制循环，但是它提供了一个更高级的break，可以选择中断哪一个循环 for循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量

### go语言中的引用类型包含哪些？

数组切片(slice)、字典(map)、通道（channel）、接口（interface）

### go语言中指针运算有哪些？

可以通过“&”取指针的地址

可以通过“*”取指针指向的数据


### 说说go语言的同步锁？
- 当一个goroutine获得了Mutex后，其他goroutine就只能乖乖的等待，除非该goroutine释放这个Mutex
- RWMutex在读锁占用的情况下，会阻止写，但不阻止读
- RWMutex在写锁占用情况下，会阻止任何其他goroutine（无论读和写）进来，整个锁相当于由该goroutine独占

### 说说go语言的channel特性？

A. 给一个 nil channel 发送数据，造成永远阻塞

B. 从一个 nil channel 接收数据，造成永远阻塞

C. 给一个已经关闭的 channel 发送数据，引起 panic

D. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值

E. 无缓冲的channel是同步的，而有缓冲的channel是非同步的

### go语言触发异常的场景有哪些？

A. 空指针解析
B. 下标越界
C. 除数为0
D. 调用panic函数


### 说说go语言的goconvey框架？

A. goconvey是一个支持golang的单元测试框架

B. goconvey能够自动监控文件修改并启动测试，并可以将测试结果实时输出到web界面

C. goconvey提供了丰富的断言简化测试用例的编写

### go语言中，GoStub的作用是什么？

A. GoStub可以对全局变量打桩

B. GoStub可以对函数打桩

C. GoStub不可以对类的成员方法打桩

D. GoStub可以打动态桩，比如对一个函数打桩后，多次调用该函数会有不同的行为

### 说说go语言的select机制？

A. select机制用来处理异步IO问题

B. select机制最大的一条限制就是每个case语句里必须是一个IO操作

C. golang在语言级别支持select关键字

### 说说进程、线程、协程之间的区别

进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元；同一个进程中可以包括多个线程；进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束。

线程共享整个进程的资源（寄存器、堆栈、上下文），一个进程至少包括一个线程；进程的创建调用fork或者vfork，而线程的创建调用pthread_create；线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源。

进程是资源分配的单位，而线程是操作系统调度的单位

进程切换需要的资源很最大，效率很低;线程切换需要的资源一般，效率一般;协程切换任务资源很小，效率高。

多进程、多线程根据cpu核数不一样可能是并行的 也可能是并发的。协程的本质就是使用当前进程在不同的函数代码中切换执行，可以理解为并行。 协程是一个用户层面的概念，不同协程的模型实现可能是单线程，也可能是多线程。

进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。（全局变量保存在堆中，局部变量及函数保存在栈中）

线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是这样的)。

协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。

一个应用程序一般对应一个进程，一个进程一般有一个主线程，还有若干个辅助线程，线程之间是平行运行的，在线程里面可以开启协程，让程序在特定的时间内运行。

协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。