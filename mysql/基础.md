# 数据库范式

1. 第一范式（1NF）：原子性，不可再分解
2. 第二范式（2NF）：唯一性，在第一范式基础上，非主键列完全依赖于主键
3. 第三范式（3NF）：独立性，在第二范式的基础上，非主键列依赖于主键，不依赖于其他非主键，消除传递依赖
4. 其他：巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）





- DDL(Database Defination Language):create、alter等
- DML(Database Manipulation Language):insert、update、delete等
- DCL(Database Control Language):grant、revoke等
- DQL(Database Query Language):select



# 事务

## 事务相关命令

> 显式启动事务语句，begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。

建议总是使用set autocommit=1, 通过显式语句的方式来启动事务。

## ACID

- **A (Atomicity) 原子性**：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样
- **C (Consistency) 一致性**：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏
- **I (Isolation) 隔离性**：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰
- **D (Durability) 持久性**：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚

## 隔离级别

查看当前隔离级别：

> show variables like 'transaction_isolation'

读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。



# 执行流程

大体来说，MySQL可以分为Server层和存储引擎层两部分。Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

执行流程如下：

1. 连接到数据库，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。

2. 查询缓存。MySQL拿到一个查询请求后，会先到查询缓存看看，如果命中，那么这个value就会被直接返回给客户端，这里也会做一个权限验证。

3. 如果没有命中查询缓存，就要开始真正执行语句了。分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。

4. 根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。

   如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒。

5. 经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。

   优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。

6. MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句返回结果。

   开始执行的时候，要先判断一下你对这个表有没有执行查询的权限，如果没有，就会返回没有权限的错误。如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。

   


需要注意：
- MySQL 8.0版本直接将查询缓存的整块功能删掉了
- 虽然优化器会自动使用索引，但有时候选取的索引未必正确





# MySQL性能与可用性分析

## WAL(Write-Ahead Loggin)机制

在MySQL里，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新。整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。

具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。



## 日志

### binlog 归档日志

事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。

一个事务的binlog是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到了binlog cache的保存问题。

系统给binlog cache分配了一片内存，每个线程一个，参数 binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。

事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。

![binlog](https://static001.geekbang.org/resource/image/9e/3e/9ed86644d5f39efb0efec595abb92e3e.png)

可以看到，每个线程有自己的binlog cache，但是共用同一份binlog文件。

图中的write，指的就是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快。

图中的fsync，才是将数据持久化到磁盘的操作。

write 和fsync的时机，是由参数sync_binlog控制的：

- sync_binlog=0的时候，表示每次提交事务都只write，不fsync；
- sync_binlog=1的时候，表示每次提交事务都会执行fsync；
- sync_binlog=N(N>1)的时候，表示每次提交事务都write，但累积N个事务后才fsync。

因此，在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成0，比较常见的是将其设置为100~1000中的某个数值。

但是，将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会丢失最近N个事务的binlog日志。



### redo log 重做日志

redo log的三种状态：

- 红色：存在redo log buffer中，物理上是在MySQL进程内存中
- 黄色：写到磁盘(write)，但是没有持久化（fsync)，物理上是在文件系统的page cache里面
- 绿色：持久化到磁盘，对应的是hard disk

![redo log](https://static001.geekbang.org/resource/image/9d/d4/9d057f61d3962407f413deebc80526d4.png)



为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参 数，它有三种可能取值:

- 0，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;
- 1，表示每次事务提交时都将 redo log 直接持久化到磁盘;
- 2 ，表示每次事务提交时都只是把 redo log 写到 page cache。

InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写 到文件系统的 page cache，然后调用 fsync 持久化到磁盘。

实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的 redo log 写入到磁盘中。

```
1. redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。
2. 并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。假设一个事务 A 执行到一半，已经写了一些 redo log 到 buffer 中，这时候有另外一个线程的事务 B 提交，如果 innodb_flush_log_at_trx_commit 设置的是1，那么按照这个参数的逻辑，事务 B 要把 redo log buffer 里的日志全部持久化到磁盘。这时候，就会带上事务 A 在 redo log buffer 里的日志一起持久化到磁盘。
```

既然MySQL能保证redo log和binlog能可靠性写入磁盘，那么在他们两者直接如何保证可靠转换的呢？

### 两阶段提交

redo log 先 prepare，再写 binlog，最后再把 redo log commit。利用这个两阶段提交机制，MySQL保证了redo log和binlog的可靠传输。

最后我们来看下整体简图：

![持久化](https://static001.geekbang.org/resource/image/5a/28/5ae7d074c34bc5bd55c82781de670c28.png)



# 存储引擎对比
> show variables like '%storage_engine%'

常见：InnoDB、MyISAM；其他：Archive、CSV、Memory等



| 对比项         | MyISAM                           | InnoDB                                                       |
| -------------- | -------------------------------- | ------------------------------------------------------------ |
| 外键           | 不支持                           | 支持                                                         |
| 事务           | 不支持                           | 支持                                                         |
| 锁             | 表锁                             | 行锁                                                         |
| 缓存           | 只缓存索引，不缓存真实数据       | 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响 |
| 关注点         | 节省资源，消耗少，简单业务，性能 | 并发写，事务，更大资源                                       |
| 默认安装       | 是                               | 是                                                           |
| 默认使用       | 否                               | 是                                                           |
| 自动系统表使用 | 是                               | 否                                                           |

应用场景：

- MyISAM管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择MyISAM

- InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB



# 索引

从底层实现来说，索引类型包括 B-Tree（InnoDB引擎）、哈希索引（Memory引擎）、空间数据索引(R-Tree， MyISAM引擎支持)、全文索引等。从索引的实现上，我们可以将其分为聚集索引与非聚集索引，或称辅助索引或二级索引；从索引的实际应用中，又可以细分为普通索引、唯一索引、主键索引、联合索引、外键索引、全文索引这几种。

[10分钟让你明白MySQL是如何利用索引的](http://www.fordba.com/spend-10-min-to-understand-how-mysql-use-index.html)

[详解Mysql索引原理及其优化](https://juejin.im/post/5d4d82caf265da039c6360ff#heading-12)



- 前缀索引: 在对一个比较长的字符串进行索引时,可以仅索引开始的一部分字符,这样可以大大的节约索引空间,从而提高索引效率。但是这样也会降低索引的选择性。
- 索引的选择性: 不重复的值/所有的值（区分度）
- 联合索引
- 聚簇索引:不是一种索引类型，而是一种存储数据的方式。InnoDB的聚簇索引是在同一个数据结构中保存了索引和数据。默认是主键，如果表中没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键作为聚簇索引
- 覆盖索引:当一个索引包含(或者说是覆盖)需要查询的所有字段的值时,我们称之为覆盖索引

## 索引优点

- 减少查询需要扫描的数据量，加快了查询速度
- 减少服务器的排序操作和创建临时表的操作(加快了groupby和orderby等操作)
- 将服务器的随机IO变为顺序IO(加快查询速度).

## 索引缺点

- 索引占用磁盘或者内存空间
- 减慢了插入更新操作的速度

> 实际上，在一定数据范围内(索引没有超级多的情况下),建立索引带来的开销是远远小于它带来的好处的，但是我们仍然要防止索引的滥用。

## explain出来的各种item的意义

- id:每个被独立执行的操作的标志，表示对象被操作的顺序。一般来说， id 值大，先被执行；如果 id 值相同，则顺序从上到下。
- select_type：查询中每个 select 子句的类型。
- table:名字，被操作的对象名称，通常的表名(或者别名)，但是也有其他格式。
- partitions:匹配的分区信息。
- type:join 类型。
- possible_keys：列出可能会用到的索引。
- key:实际用到的索引。
- key_len:用到的索引键的平均长度，单位为字节。
- ref:表示本行被操作的对象的参照对象，可能是一个常量用 const 表示，也可能是其他表的key 指向的对象，比如说驱动表的连接列。
- rows:估计每次需要扫描的行数。
- filtered:rows*filtered/100 表示该步骤最后得到的行数(估计值)。
- extra:重要的补充信息。



# 锁

> 根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表锁和行锁三类。

## 全局锁

顾名思义，全局锁就是对整个数据库实例加锁。

MySQL提供了一个加全局读锁的方法，命令是

> Flush tables with read lock (FTWRL)。

当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

> 典型使用场景是，做全库逻辑备份。

官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。

## 表锁

MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

表锁的语法是

> lock tables … read/write。

与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

举个例子, 如果在某个线程A中执行

> lock tables t1 read, t2 write

这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。

在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。

另一类表级的锁是MDL（metadata lock)。

MDL不需要显式使用，在访问一个表的时候会被自动加上。

> MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。

因此，在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

虽然MDL锁是系统默认会加的，但却是你不能忽略的一个机制。比如有人掉到这个坑里：给一个小表加个字段，导致整个库挂了。

## 行锁

MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，如MyISAM引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，这也是MyISAM被InnoDB替代的重要原因之一。

> 在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议

### 间隙锁

gap lock，也就是间隙锁，是innodb行级锁的一种，其他的还有record lock, Next-KeyLocks。

- 行锁（Record Lock）：锁直接加在索引记录上面。
- 间隙锁（Gap Lock）：锁加在不存在的空闲空间，可以是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。
- Next-Key Lock：行锁与间隙锁组合起来用就叫做Next-Key Lock。

####  什么时候会取得gap lock

这和隔离级别有关,只在REPEATABLE READ或以上的隔离级别下的特定操作才会取得gap lock或next-key lock。
locking reads，UPDATE和DELETE时，除了对唯一索引的唯一搜索外都会获取gap锁或next-key锁。即锁住其扫描的范围。 

## 死锁

所谓死锁: 是指两个或两个以上的进程在执行过程中, 因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。

当出现死锁以后，有两种策略：

- 策略1是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。 
- 策略2是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。



# MySQL主从复制原理

MySQL主从复制是构建高可用MySQL的基础，复制就是让一台服务器的数据和其它服务器保持同步，一台主库可以同步到多台备库上面，备库也可以作为另一台服务器的主库。主库和备库之间可以有多种不同的组合方式。

### 主从复制延迟

产生延迟原因：

- 主节点如果执行一个很大的事务(更新千万条语句，执行很长时间的事务)，那么就会对主从延迟产生较大的影响
- 网络延迟，日志较大，slave数量过多。
- 主节点多线程写入，从节点只有单线程恢复

处理办法：

- 大事务：将大事务分为小事务，分批处理数据。
- 减少Slave的数量，不要超过5个，减少单次事务的大小。
- MySQL 5.7之后，可以使用多线程复制，使用MGR复制架构
